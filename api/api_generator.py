"""
Enterprise API Generator
Generates production-ready REST and GraphQL APIs with full documentation
"""
import os
import json
from typing import Dict, List, Any, Optional
import google.generativeai as genai


class APIGenerator:
    """Generates enterprise-grade APIs"""
    
    def __init__(self):
        api_key = os.getenv("GEMINI_API_KEY")
        if api_key:
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('gemini-2.0-flash')
        else:
            self.model = None
    
    async def design_api_spec(self, requirements: str, entities: List[str]) -> Dict[str, Any]:
        """Design OpenAPI/REST API specification"""
        
        if not self.model:
            return {"error": "AI model not configured"}
        
        entities_str = ", ".join(entities)
        
        prompt = f"""Design a production-ready REST API specification for:

REQUIREMENTS: {requirements}
ENTITIES: {entities_str}

Return OpenAPI 3.0 specification in JSON:
{{
    "openapi": "3.0.0",
    "info": {{
        "title": "API Title",
        "version": "1.0.0",
        "description": "API description"
    }},
    "paths": {{
        "/api/v1/resources": {{
            "get": {{
                "summary": "List all resources",
                "parameters": [{{"name": "page", "in": "query", "schema": {{"type": "integer"}}}}],
                "responses": {{
                    "200": {{"description": "Success", "schema": {{"type": "array"}}}}
                }}
            }},
            "post": {{
                "summary": "Create resource",
                "requestBody": {{"required": true, "content": {{"application/json": {{"schema": {{"type": "object"}}}}}}}},
                "responses": {{
                    "201": {{"description": "Created"}}
                }}
            }}
        }},
        "/api/v1/resources/{{id}}": {{
            "get": {{"summary": "Get resource by ID"}},
            "put": {{"summary": "Update resource"}},
            "delete": {{"summary": "Delete resource"}}
        }}
    }},
    "components": {{
        "schemas": {{
            "Resource": {{
                "type": "object",
                "properties": {{
                    "id": {{"type": "integer"}},
                    "name": {{"type": "string"}},
                    "created_at": {{"type": "string", "format": "date-time"}}
                }},
                "required": ["name"]
            }}
        }},
        "securitySchemes": {{
            "bearerAuth": {{
                "type": "http",
                "scheme": "bearer",
                "bearerFormat": "JWT"
            }}
        }}
    }}
}}"""
        
        try:
            response = self.model.generate_content(prompt)
            text = response.text.strip()
            
            # Extract JSON from response
            import re
            json_match = re.search(r'\{.*\}', text, re.DOTALL)
            if json_match:
                return json.loads(json_match.group())
            return {"raw_spec": text}
        except Exception as e:
            return {"error": str(e)}
    
    async def generate_fastapi_endpoints(self, spec: Dict[str, Any], entities: List[str]) -> str:
        """Generate FastAPI endpoint code"""
        
        code = '''\"\"\"
FastAPI Endpoints
Generated by SuperAgent Enterprise
\"\"\"
from fastapi import APIRouter, HTTPException, Query, Depends
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel

# Import models and database
# from models import User, Post
# from database import get_db

router = APIRouter(prefix="/api/v1", tags=["resources"])

# Pydantic schemas for request/response validation
'''
        
        for entity in entities:
            entity_lower = entity.lower()
            entity_title = entity.title()
            
            # Create Pydantic schemas
            code += f"""
class {entity_title}Create(BaseModel):
    \"\"\"Schema for creating {entity_lower}\"\"\"
    # Add fields here
    pass

class {entity_title}Update(BaseModel):
    \"\"\"Schema for updating {entity_lower}\"\"\"
    # Add fields here
    pass

class {entity_title}Response(BaseModel):
    \"\"\"Schema for {entity_lower} response\"\"\"
    id: int
    created_at: datetime
    
    class Config:
        from_attributes = True

"""
            
            # Create CRUD endpoints
            code += f"""
@router.get("/{entity_lower}s", response_model=List[{entity_title}Response])
async def list_{entity_lower}s(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    \"\"\"List all {entity_lower}s with pagination\"\"\"
    # query = db.query({entity_title}).offset(skip).limit(limit).all()
    # return query
    pass

@router.post("/{entity_lower}s", response_model={entity_title}Response, status_code=201)
async def create_{entity_lower}(
    item: {entity_title}Create,
    db: Session = Depends(get_db)
):
    \"\"\"Create a new {entity_lower}\"\"\"
    # db_item = {entity_title}(**item.dict())
    # db.add(db_item)
    # db.commit()
    # db.refresh(db_item)
    # return db_item
    pass

@router.get("/{entity_lower}s/{{id}}", response_model={entity_title}Response)
async def get_{entity_lower}(
    id: int,
    db: Session = Depends(get_db)
):
    \"\"\"Get {entity_lower} by ID\"\"\"
    # item = db.query({entity_title}).filter({entity_title}.id == id).first()
    # if not item:
    #     raise HTTPException(status_code=404, detail="{entity_lower} not found")
    # return item
    pass

@router.put("/{entity_lower}s/{{id}}", response_model={entity_title}Response)
async def update_{entity_lower}(
    id: int,
    item: {entity_title}Update,
    db: Session = Depends(get_db)
):
    \"\"\"Update {entity_lower}\"\"\"
    # db_item = db.query({entity_title}).filter({entity_title}.id == id).first()
    # if not db_item:
    #     raise HTTPException(status_code=404, detail="{entity_lower} not found")
    # for key, value in item.dict(exclude_unset=True).items():
    #     setattr(db_item, key, value)
    # db.commit()
    # db.refresh(db_item)
    # return db_item
    pass

@router.delete("/{entity_lower}s/{{id}}", status_code=204)
async def delete_{entity_lower}(
    id: int,
    db: Session = Depends(get_db)
):
    \"\"\"Delete {entity_lower}\"\"\"
    # db_item = db.query({entity_title}).filter({entity_title}.id == id).first()
    # if not db_item:
    #     raise HTTPException(status_code=404, detail="{entity_lower} not found")
    # db.delete(db_item)
    # db.commit()
    pass

"""
        
        code += """
# Main app setup
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(
    title="Enterprise API",
    description="Production-ready API",
    version="1.0.0"
)

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(router)

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
"""
        
        return code
    
    async def generate_openapi_docs(self, spec: Dict[str, Any]) -> str:
        """Generate OpenAPI documentation in YAML format"""
        
        docs = """openapi: 3.0.0
info:
  title: Enterprise API
  version: 1.0.0
  description: Production-ready REST API

servers:
  - url: https://api.example.com
    description: Production
  - url: http://localhost:8000
    description: Development

paths:
  /api/v1/health:
    get:
      summary: Health check
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    Error:
      type: object
      properties:
        detail:
          type: string
        status_code:
          type: integer

security:
  - bearerAuth: []
"""
        
        return docs
    
    async def generate_complete_api(self, requirements: str, entities: List[str]) -> Dict[str, Any]:
        """Complete API generation workflow"""
        
        # Step 1: Design API spec
        spec = await self.design_api_spec(requirements, entities)
        if "error" in spec:
            return spec
        
        # Step 2: Generate FastAPI endpoints
        fastapi_code = await self.generate_fastapi_endpoints(spec, entities)
        
        # Step 3: Generate OpenAPI docs
        openapi_docs = await self.generate_openapi_docs(spec)
        
        return {
            "success": True,
            "spec": spec,
            "fastapi_code": fastapi_code,
            "openapi_docs": openapi_docs,
            "files_to_create": [
                "main.py",
                "routes/resources.py",
                "schemas.py",
                "openapi.yaml"
            ],
            "endpoints": [
                "GET /api/v1/resources",
                "POST /api/v1/resources",
                "GET /api/v1/resources/{id}",
                "PUT /api/v1/resources/{id}",
                "DELETE /api/v1/resources/{id}"
            ]
        }


# Global instance
api_generator = APIGenerator()
